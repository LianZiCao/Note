## 固定功能
之前的许多图形API会为管线提供一些默认的状态。在Vulkan不存在默认状态，所有状态必须被显式地设置，无论是视口大小，还是使用的颜色混合函数都需要显式地指定。在本章节，我们开始对固定功能阶段进行配置。
### 动态状态
动态状态指的是在绘制时可以更改的管线状态。尽管大多数管线状态（pipeline state）需要在创建管线时固定下来，但仍有一小部分状态可以在不重新创建管线的情况下进行修改。例如，视口（viewport）的大小、线宽（line width）和混合常数（blend constants）等。

如果希望使用动态状态并将这些属性排除在固定管线状态之外，就需要填充 `VkPipelineDynamicStateCreateInfo` 结构体，如下所示：
```c++
std::vector<VkDynamicState> dynamicStates = {
    VK_DYNAMIC_STATE_VIEWPORT,
    VK_DYNAMIC_STATE_SCISSOR
};

VkPipelineDynamicStateCreateInfo dynamicState{};
dynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
dynamicState.dynamicStateCount = static_cast<uint32_t>(dynamicStates.size());
dynamicState.pDynamicStates = dynamicStates.data();
```
这样一来，这些值的配置将在管线创建时被忽略，而必须在绘制时进行指定。这种方式提供了更灵活的设置方式，并且对于视口（viewport）和裁剪（scissor）状态等非常常见，因为如果它们被固定在管线状态中，可能会导致更复杂的管线管理。

### 顶点输入
我们可以使用`VkPipelineVertexInputStateCreateInfo`结构体来描述传递给顶点着色器的顶点数据格式。描述内容主要包括下面两个方面：

 绑定：数据之间的间距和数据是按逐顶点的方式还是按逐实例的方式进行组织
 属性描述：传递给顶点着色器的属性类型，用于将属性绑定到顶点着色器中的变量

由于我们直接在顶点着色器中硬编码顶点数据，所以我们填写结构体信息时指定不载入任何顶点数据。在后面的顶点缓冲章节，我们就会真正地载入顶点数据。
```c++
VkPipelineVertexInputStateCreateInfo vertexInputInfo{};
vertexInputInfo.sType = VK_STRUCTURE_TYPE_PIPELINE_VERTEX_INPUT_STATE_CREATE_INFO;
vertexInputInfo.vertexBindingDescriptionCount = 0;
vertexInputInfo.pVertexBindingDescriptions = nullptr; // Optional
vertexInputInfo.vertexAttributeDescriptionCount = 0;
vertexInputInfo.pVertexAttributeDescriptions = nullptr; // Optional
```
`pVertexBindingDescriptions`和`pVertexAttributeDescriptions`成员变量用于指向描述顶点数据组织信息地结构体数组。我们在`createGraphicsPipeline`函数中的`shaderStages`数组定义之后定义这一结构体。

### 输入装配
`VkPipelineInputAssemblyStateCreateInfo`结构体用于描述两个信息：顶点数据定义了哪种类型的几何图元，以及是否启用几何图元重启。前一个信息通过`topology`成员变量指定，它的值可以是下面这些：

 `VK_PRIMITIVE_TOPOLOGY_POINT_LIST`：点图元

 `VK_PRIMITIVE_TOPOLOGY_LINE_LIST`：每两个顶点构成一个线段图元

 `VK_PRIMITIVE_TOPOLOGY_LINE_STRIP`：每两个顶点构成一个线段图元，除第一个线段图元外，每个线段图元使用上一个线段图元的一个顶点

 `VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST`：每三个顶点构成一个三角形图元

 `VK_PRIMITIVE_TOPOLOGY_TRIANGLE_STRIP`：每个三角形的第二个和第三个顶点被下一个三角形作为第一和第二个顶点使用

一般而言，我们会通过索引缓冲来更好地复用顶点缓冲中的顶点数据。如果将`primitiveRestartEnable`成员变量的值设置为`VK_TRUE`，那么如果使用带有`_STRIP`结尾的图元类型，可以通过一个特殊索引值0xFFFF或0xFFFFFFFF达到重启图元的目的(从特殊索引值之后的索引重置为图元的第一个顶点)。

我们的目的是绘制三角形，可以按照下面代码填写结构体：
```c++
VkPipelineInputAssemblyStateCreateInfo inputAssembly{};
inputAssembly.sType = VK_STRUCTURE_TYPE_PIPELINE_INPUT_ASSEMBLY_STATE_CREATE_INFO;
inputAssembly.topology = VK_PRIMITIVE_TOPOLOGY_TRIANGLE_LIST;
inputAssembly.primitiveRestartEnable = VK_FALSE;
```
### 视口与裁剪
视口用于描述被用来输出渲染结果的帧缓冲区域。一般而言，会将它设置为`(0，0)`到`(width，height)`，在本教程，我们也采取这一设置：
```c++
VkViewport viewport{};
viewport.x = 0.0f;
viewport.y = 0.0f;
viewport.width = (float) swapChainExtent.width;
viewport.height = (float) swapChainExtent.height;
viewport.minDepth = 0.0f;
viewport.maxDepth = 1.0f;
```
注意交换链尺寸可能与窗口不同，此处使用交换链尺寸以确保兼容性。

`minDepth`和`maxDepth`成员变量用于指定帧缓冲使用的深度值的范围。它们的值必须在`[0.0f，1.0f]`之中，特别的，`minDepth`的值可以大于`maxDepth`的值。如果读者没有特殊需要，一般将它们的值分别设置为`0.0f`和`1.0f`。

视口定义了图像到帧缓冲的映射关系，裁剪矩形定义了哪一区域的像素实际被存储在帧缓存。任何位于裁剪矩形外的像素都会被光栅化程序丢弃。视口和裁剪的工作方式在下图中给出
![photo](../photo/viewports_scissors.png)
在本教程，我们在整个帧缓冲上进行绘制操作，所以将裁剪范围设置为和帧缓冲大小一样
```c++
VkRect2D scissor{};
scissor.offset = {0, 0};
scissor.extent = swapChainExtent;
```
视口和剪刀矩形既可以指定为流水线的静态部分，也可以指定为命令缓冲区中的动态状态。虽然前者与其他状态更为一致，但将视口和剪刀状态设置为动态往往更为方便，因为它能为你提供更多的灵活性。这种情况非常普遍，所有实现都可以处理这种动态状态，而不会影响性能。
选择动态视口和剪刀矩形时，需要为管道启用相应的动态状态：
```c++
std::vector<VkDynamicState> dynamicStates = {
    VK_DYNAMIC_STATE_VIEWPORT,
    VK_DYNAMIC_STATE_SCISSOR
};

VkPipelineDynamicStateCreateInfo dynamicState{};
dynamicState.sType = VK_STRUCTURE_TYPE_PIPELINE_DYNAMIC_STATE_CREATE_INFO;
dynamicState.dynamicStateCount = static_cast<uint32_t>(dynamicStates.size());
dynamicState.pDynamicStates = dynamicStates.data();
```
然后，只需在创建管道时指定它们的数量：
```c++
VkPipelineViewportStateCreateInfo viewportState{};
viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
viewportState.viewportCount = 1;
viewportState.scissorCount = 1;
```
实际的视口和剪切矩形随后将在绘图时设置。

有了动态状态，甚至可以在单个命令缓冲区内指定不同的视口和剪刀矩形。

如果没有动态状态，则需要使用 VkPipelineViewportStateCreateInfo 结构在流水线中设置视口和剪刀矩形。这使得该流水线的视口和剪刀矩形不可更改。如果需要更改这些值，则需要使用新值创建新管道。
```c++
VkPipelineViewportStateCreateInfo viewportState{};
viewportState.sType = VK_STRUCTURE_TYPE_PIPELINE_VIEWPORT_STATE_CREATE_INFO;
viewportState.viewportCount = 1;
viewportState.pViewports = &viewport;
viewportState.scissorCount = 1;
viewportState.pScissors = &scissor;
```
无论您如何设置，在某些显卡上都可以使用多个视口和剪刀矩形，因此结构成员会引用它们的数组。使用多个视口需要启用 GPU 功能（请参阅逻辑设备创建）。

### 光栅化
光栅化器从顶点着色器中获取由顶点塑造的几何体，并将其转化为片段，由片段着色器着色。它还会执行深度测试、面剔除和剪刀测试，并可配置为输出填充整个多边形或仅填充边缘的片段（线框渲染）。所有这些都可以通过 `VkPipelineRasterizationStateCreateInfo` 结构进行配置。
```c++
VkPipelineRasterizationStateCreateInfo rasterizer{};
rasterizer.sType = VK_STRUCTURE_TYPE_PIPELINE_RASTERIZATION_STATE_CREATE_INFO;
rasterizer.depthClampEnable = VK_FALSE;
```
`depthClampEnable`成员变量设置为`VK_TRUE`表示在近平面和远平面
外的片段会被截断为在近平面和远平面上，而不是直接丢弃这些片段。这
对于阴影贴图的生成很有用。使用这一设置需要开启相应的GPU特性。
```c++
rasterizer.rasterizerDiscardEnable = VK_FALSE;
```
`rasterizerDiscardEnable`成员变量设置为`VK_TRUE`表示所有几何图元都不能通过光栅化阶段。这一设置会禁止一切片段输出到帧缓冲。
```c++
rasterizer.polygonMode = VK_POLYGON_MODE_FILL;
```
`polygonMode`成员变量用于指定几何图元生成片段的方式。它可以是下面这些值：

 `VK_POLYGON_MODE_FILL`：整个多边形，包括多边形内部都产生片段

 `VK_POLYGON_MODE_LINE`：只有多边形的边会产生片段

 `VK_POLYGON_MODE_POINT`：只有多边形的顶点会产生片段

使用除了`VK_POLYGON_MODE_FILL`外的模式，需要启用相应的GPU特性。
```c++
rasterizer.lineWidth = 1.0f;
```
`lineWidth`成员变量用于指定光栅化后的线段宽度，它以线宽所占的片段数目为单位。线宽的最大值依赖于硬件，使用大于`1.0f`的线宽，需要启用相应的GPU特性。
```c++
rasterizer.cullMode = VK_CULL_MODE_BACK_BIT;
rasterizer.frontFace = VK_FRONT_FACE_CLOCKWISE;
```
`cullMode`成员变量用于指定使用的表面剔除类型。我们可以通过它禁用表面剔除，剔除背面，剔除正面，以及剔除双面。`frontFace`成员变量用于指定顺时针的顶点序是正面，还是逆时针的顶点序是正面。
```c++
rasterizer.depthBiasEnable = VK_FALSE;
rasterizer.depthBiasConstantFactor = 0.0f; // Optional
rasterizer.depthBiasClamp = 0.0f; // Optional
rasterizer.depthBiasSlopeFactor = 0.0f; // Optional
```
光栅化程序可以添加一个常量值或是一个基于片段所处线段的斜率得到的变量值到深度值上。这对于阴影贴图会很有用，但在这里，我们不使用它，所以将`depthBiasEnable`成员变量设置为`VK_FALSE`。