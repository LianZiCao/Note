[Get Started with Win32 and C++](https://learn.microsoft.com/en-us/windows/win32/learnwin32/learn-to-program-for-windows)

## windows编码约定

### 类型

许多typedef都被定义在`WinDef.h`
Data type|	Size|	Signed?
------|---------|------------
BYTE|	8 bits|	Unsigned
DWORD|	32 bits|	Unsigned
INT32|	32 bits|	Signed
INT64|	64 bits|	Signed
LONG|	32 bits|	Signed
LONGLONG|	64 bits|	Signed
UINT32|	32 bits|	Unsigned
UINT64|	64 bits|	Unsigned
ULONG|	32 bits|	Unsigned
ULONGLONG|	64 bits|	Unsigned
WORD|	16 bits|	Unsigned

`DWORD`即`Double Word`，每个word为2个字节的长度，是指计算机中数值的位数(4字节，32位)

`BOOL`是`int`类型的别名
```c++
#define FALSE    0 
#define TRUE     1
```


大多数返回`BOOL`的函数能够返回非零值来表示布尔真值
正确方式即
```c++
if(func()){
    //...
}

//or

if(func() != FALSE){
    ///
}
```

不要写成`result == TRUE`

前缀`P-`和`LP-`表指针。`LP-`是为16为设计的，现在而这无区别，必须使用其一则用`P-



下面的类型大小总是指针大小，换言之，32位应用32bit，64位64bit
* DWORD_PTR
* INT_PTR
* LONG_PTR
* ULONG_PTR
* UINT_PTR`

这些类型在一个整型被转换为指针时使用，也用于定义指针运算的变量，遍历缓冲区所有字节的循环计数器，在64位windows中32位置扩展到64位

### 匈牙利命名法

例如`cb`即count of bytes，`rw`和`col`意味着row和column数，dw即DWORD，w即WORD.

## 有关字符串

UTF-16编码，每个字符都被编码为一个或两个16bit值
ANSI编码，8bit值
为了区分，UTF-16使用了宽字符类型
```c++
typedef wchar_t WCHAR;
```
为了声明宽字符字面量，在字符串前面加'L'
```c++
wchar_t a = L'a';
wchar_t *str = L"hello";
```
一些字符串相关的typedef
Typedef	|Definition
-------|--------
CHAR	|char
PSTR or LPSTR	|char*
PCSTR or LPCSTR	|const char*
PWSTR or LPWSTR	|wchar_t*
PCWSTR or LPCWSTR	|const wchar_t*

### Unicode和ANSI函数
* SetWindowTextA使用ANSI字符串
* SetWindowTextW使用Unicode字符串

在内部，ANSI的版本被转换成Unicode。windows也提供了一个宏，如果定义了`UNICODE`转换为unicode版本，否则ansi版本
```c++
#ifdef UNICODE
#define SetWindowText  SetWindowTextW
#else
#define SetWindowText  SetWindowTextA
#endif
```
该函数文档名为`SetWindowText`，尽管这是宏名字而非实际的函数名字

对于现在的应用都应该用unicode版，用ansi则无法本地化，并且因为要在运行时转换为unicode效率更低。取决于偏好可以使用`SetWindowTextW`或者宏

### TCHARs
在某些情况下为unicode或ansi编译相同的代码很有用，windows sdk提供宏映射字符串到unicode或ansi，取决于平台

Macro|	Unicode|	ANSI
-----|---------|----
TCHAR|	wchar_t|	char
TEXT("x") or _T("x")|	L"x"|	"x"

当然现在TEXT和TCHAR都用得很少因为现在都用unicode

一些头文件使用预处理符`_UNICODE`和`UNICODE`。总是要定义这两，并且visual c++在创建新项目的时候总是默认定义他们两个

## 窗口

![windows](../photo/window01.png)
*application window* 或者*main window*，通常有一个带标题栏，最小化和最大化按钮以及其他UI元素的框架。因为操作系统管理窗口的框架的这一部分，框架被称为窗口的*non-client area*。里面的部分称为*client area*归应用程序管。

![windows](../photo/window02.png)
（窗口的其他类型）
UI控件，例如按钮和编辑栏全是窗口。UI控件和应用窗口的最大区别是UI空间因他自己存在，相反的位置相对于应用窗口。

### 父窗口和所有窗口
对于UI控件的情况，控件窗口被称为应用窗口的子窗口，反过来应用窗口是控件窗口的父窗口。父窗口为子窗口的定位提供坐标系
![windows](../photo/window03.png)
应用程序窗口，所有窗口
对话窗口，被所有窗口

被所有窗口总是在所有窗口上面，并且随着所有窗口最小化和销毁。
![windows](../photo/window04.png)
### 窗口句柄
项目通过使用句柄来应用窗口，数据类型即`HWND`。窗口句柄被`CreateWindow`和`CreateWindowEx`两个函数返回。为了对窗口进行操作，必须调用以句柄为参数的函数，例如`MoveWindow`
```c++
BOOL MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint);
```
`hwnd`是一个包含句柄的变量，不能解引用，否则会出错

### 屏幕和窗口坐标
坐标以设备无关像素衡量。(0, 0) 总是左上角坐标
![windows](../photo/coordinates01.png)

## WinMain应用入口点
每一个windows程序包含一个名为WinMain或者wWinMain的入口点
wWinMain的签名：
```c++
int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PWSTR pCmdLine, int nCmdShow);
```
* *hInstance*是对一个模块或示例的句柄
* *hPrevInstance*被用在16bit windows，现在无意义，总为0
* *pCmdLine*包含以Unicode字符串的命令行参数
* *nCmdShow*是一个指示程序是否最小化，最大化或者正常显示的标志

操作系统不使用函数返回值，但是可以用返回值给另外一个程序传递状态代码

调用约定，例如`WINAPI`定义了一个函数如何从调用者那里获得参数

WinMain和wWinMain差别是pCmdLine以ANSI字符串传递
[GetCommandLineA function (processenv.h)](https://learn.microsoft.com/en-us/windows/win32/api/processenv/nf-processenv-getcommandlinea)
[CommandLineToArgvW function (shellapi.h)](https://learn.microsoft.com/en-us/windows/win32/api/shellapi/nf-shellapi-commandlinetoargvw)

Microsoft C runtime library (CRT) 里面提供了main函数调用WinMain或wWinMain的实现

The CRT does some more work inside main. For example, it calls any static initializers before wWinMain. Although you can tell the linker to use a different entry-point function, you should use the default if you link to the CRT. Otherwise, the CRT initialization code is skipped, with unpredictable results such as global objects not being initialized correctly.

空wWinMain
```c++
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
    PSTR lpCmdLine, int nCmdShow)
{
    return 0;
}
```

## 空白应用示例
[Walkthrough: Create a traditional Windows Desktop application (C++)](https://learn.microsoft.com/en-us/cpp/windows/walkthrough-creating-windows-desktop-applications-cpp?view=msvc-170)

```c++
#ifndef UNICODE
#define UNICODE
#endif 

#include <windows.h>

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PWSTR pCmdLine, int nCmdShow)
{
    // Register the window class.
    const wchar_t CLASS_NAME[]  = L"Sample Window Class";
    
    WNDCLASS wc = { };

    wc.lpfnWndProc   = WindowProc;
    wc.hInstance     = hInstance;
    wc.lpszClassName = CLASS_NAME;

    RegisterClass(&wc);

    // Create the window.

    HWND hwnd = CreateWindowEx(
        0,                              // Optional window styles.
        CLASS_NAME,                     // Window class
        L"Learn to Program Windows",    // Window text
        WS_OVERLAPPEDWINDOW,            // Window style

        // Size and position
        CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,

        NULL,       // Parent window    
        NULL,       // Menu
        hInstance,  // Instance handle
        NULL        // Additional application data
        );

    if (hwnd == NULL)
    {
        return 0;
    }

    ShowWindow(hwnd, nCmdShow);

    // Run the message loop.

    MSG msg = { };
    while (GetMessage(&msg, NULL, 0, 0) > 0)
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    return 0;
}

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_DESTROY:
        PostQuitMessage(0);
        return 0;

    case WM_PAINT:
        {
            PAINTSTRUCT ps;
            HDC hdc = BeginPaint(hwnd, &ps);

            // All painting occurs here, between BeginPaint and EndPaint.

            FillRect(hdc, &ps.rcPaint, (HBRUSH) (COLOR_WINDOW+1));

            EndPaint(hwnd, &ps);
        }
        return 0;

    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}
```
* wWinMain，入口点
* 填写WNDCLASS，填写窗口过程，句柄，类名
* RegisterClass注册类
* CreateWindowEx创建窗口
* ShowWindow显示窗口
* 消息循环，GetMessage，TranslateMessage，DispatchMessage

程序并未显式调用WindowProc。

每个窗口不同的数据称为实例数据（instance data）。每个窗口必须与一个窗口类（window class）相关联。

类名是当前进程的本地名称，因此名称只需在进程内唯一。不过，标准的 Windows 控件也有类。如果使用这些控件，则必须选择与控件类名不冲突的类名。例如，按钮控件的窗口类名为 Button。

[WNDCLASSA structure (winuser.h)](https://learn.microsoft.com/en-us/windows/win32/api/winuser/ns-winuser-wndclassa)
[RegisterClassA function (winuser.h)](https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-registerclassa)
[CreateWindowExA function (winuser.h)](https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-createwindowexa)
[Window Styles](https://learn.microsoft.com/en-us/windows/win32/winmsg/window-styles)


### 窗口消息
一个应用可以有几个窗口，每个窗口都有自己的窗口过程。

操作系统会为每个创建窗口的线程创建一个窗口消息队列。该队列为该线程创建的所有窗口保存消息。队列本身对程序是隐藏的。你无法直接操作队列。不过，您可以通过调用 [GetMessage](https://learn.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-getmessage) 函数从队列中提取消息。
```c++
MSG msg;
GetMessage(&msg, NULL, 0, 0);
```
该函数从队列头部删除第一条消息。如果队列为空，该函数将阻塞，直到有其他消息进入队列。无消息时程序实际上是无事可做，如果要进行后台处理可以创建额外进程让GetMessage等待消息时继续运行。

GetMessage的其他三个参数用于过滤从队列中获取的信息。几乎在所有情况下，都会将这些参数设置为零。

TranslateMessage 函数与键盘输入有关。它将按键（下键、上键）转换为字符。不必了解该函数的工作原理，只需记住在调用 DispatchMessage 之前调用该函数即可。

DispatchMessage 函数告诉操作系统调用消息目标窗口的窗口过程。换句话说，操作系统会在窗口表中查找窗口句柄，找到与窗口相关的函数指针，并调用该函数。

窗口过程返回时，会返回 DispatchMessage。这将返回消息循环以获取下一条消息。只要程序还在运行，消息就会不断到达队列，因此必须有循环

通常，GetMessage 返回一个非零值，要退出应用程序并脱离消息循环，则调用 PostQuitMessage 函数

```c++
PostQuitMessage(0);
```

PostQuitMessage 函数会在消息队列中加入一条 WM_QUIT 消息。

WM_QUIT 特殊，会导致 GetMessage 返回零

有趣的是，窗口过程永远不会收到 WM_QUIT 消息，故不必在窗口过程中为该消息设置 case 语句

有时，操作系统会绕过队列直接调用窗口过程
post消息即表示消息进入消息队列，并通过消息循环
send消息即表示跳过队列直接由操作系统调用窗口过程

应用程序在窗口之间传播消息时这点就会有所区别

### 窗口过程
窗口过程签名
```c++
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
```
CALLBACK即函数的调用约定

lParam和wParam都是一个指针的大小，具体含义取决于消息代码。对每种消息，都需要查阅消息代码然后把参数转换为正确的数据类型。

在窗口过程执行期间，它会阻止在同一线程上创建的窗口的任何其他消息，因此避免在窗口过程中过长的处理

例如，程序打开了一个 TCP 连接，并无限期地等待服务器响应。如果在窗口过程中这样做，用户界面将不会响应，直到请求完成。在此期间，窗口无法处理鼠标或键盘输入、重新绘制甚至关闭。

相反，应该使用 Windows 内置的多任务处理工具，将工作转移到另一个线程中：
* 创建新线程。
* 使用线程池。
* 使用异步 I/O 调用。
* 使用异步过程调用。

### 绘制窗口
有时，程序会启动绘制来更新窗口的外观。有时，操作系统会通知您必须重新绘制窗口的一部分。此时，操作系统会向窗口发送一条 WM_PAINT 消息。必须绘制的窗口部分称为更新区域。

窗口首次显示时，必须绘制窗口的整个客户端区域。因此，在显示窗口时，总是会收到至少一条 WM_PAINT 消息。
![painting](../photo/painting01.png)

周围的框架（标题栏，最大化）是由操作系统绘制。完成客户端区域的绘制后将清除更新区域，将告诉操作系统，在发生变化之前，它不需要发送另一条 WM_PAINT 消息。窗口被遮住的部分再次可见时，这部分区域会被添加为更新区域，窗口会收到另外一条WM_PAINT消息
![painting](../photo/painting02.png)
拉伸窗口也会导致更新
![painting](../photo/painting03.png)
```c++
switch (uMsg)
{
    case WM_PAINT:
    {
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hwnd, &ps);

        // All painting occurs here, between BeginPaint and EndPaint.

        FillRect(hdc, &ps.rcPaint, (HBRUSH) (COLOR_WINDOW+1));

        EndPaint(hwnd, &ps);
    }
    return 0;
}
```
通过调用 [BeginPaint](https://learn.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-beginpaint) 函数开始绘制操作。该函数将重绘请求的信息填入 PAINTSTRUCT 结构。PAINTSTRUCT 的 rcPaint 成员给出了当前的更新区域。该更新区域是相对于客户端区域定义的。hdc即handle to a display device
![painting](../photo/painting04.png)

[FillRect](https://learn.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-fillrect)是 Graphics Device Interface (GDI)的一部分。在 Windows 7 中，微软引入了一个名为 Direct2D 的新图形引擎，它支持高性能图形操作，例如硬件加速。

完成绘制后，调用 EndPaint 函数。该函数将清除更新区域，向 Windows 发出窗口已完成绘制的信号。