## 前缀和与差分
前缀和 与 差分是一对互逆过程
比如你有这么一段数：
1 3 5 4 6 8 9
差分化：计算出前一项与本项的差 b[1] = a[1] ,b[n] = a[n] - a[n - 1]
1 2 2 -1 2 2 1
前缀和：将前面的全加起来
1 3 5 4 6 8 9

区间值求和：前缀和
区间值修改：差分

### 一维前缀和与差分

前缀和
$b_1=a_1,b_n=a_n+a_{n-1}$
$[l,r]$求和则$b_r-b_{l-1}$
(可以认为$a_0=0$直接$b_n=a_n+a_{n-1}$，差分同理)
注意是`sum[i] = pre[i] + sum[i - 1];`
不是`sum[i] = pre[i] + pre[i - 1];`

差分
$b_1=a_1,b_n=a_n+a_{n-1}$

例题：
[P2367 语文成绩](https://www.luogu.com.cn/problem/P2367)
```C++
#include<iostream>
#include<vector>
#include<limits.h>

using namespace std;

int main() {
	int n, p;
	cin >> n >> p;
	vector<int> sum(n+2);
	for (int i = 1; i <= n; i++) {
		cin >> sum[i];
	}
	vector<int> pre(n + 2);
	for (int i = 1; i <= n; i++) {
		pre[i] = sum[i] - sum[i - 1];
	}
	while (p--) {
		int x, y,z;
		cin >> x >> y >> z;
		pre[x] += z;
		pre[y + 1] -= z;
	}
	int min = INT_MAX;
	for (int i = 1; i <= n; i++) {
		sum[i] = pre[i] + sum[i - 1];
		if (min > sum[i])
			min = sum[i];
	}
	cout << min;

}
```

### 二维前缀和与差分
前缀和：
$S_{i,j}=\displaystyle \sum_{i'\leq i} \sum_{j'\leq j}A_{i',j'}$
容斥原理可得递推关系：
$S_{i,j}=A_{i,j}+S_{i-1,j}+S_{i,j-1}-S_{i-1,j-1}$

实现时直接遍历$(i,j)$求和即可
要查询左上角$(i_1,j_1)$右下角$(i_2,j_2)$的子矩阵和，可以计算
$S_{i_2,j_2}-S_{i_1,j_2}-S_{i_2,j_1}+S_{i_1,j_1}$

![求绿色部分](photo\s.png)
* 求绿色部分$A_{i,j}$到$A_{p,q}$
用$S_{p,q}-S_{i-1,q}-S_{p,j-1}+S_{i-1,j-1}$

例题：[P2004 领地选择](https://www.luogu.com.cn/problem/P2004)
```C++
#include<iostream>
#include<vector>
#include<limits.h>

using namespace std;

int pre[1010][1010] = {};
int sum[1010][1010] = {};

int main() {
	
	int n, m, c;
	cin >> n >> m >> c;
	
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			cin >> pre[i][j];
		}
	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + pre[i][j];
			
			//cout << sum[i][j]<<' ';
		}
		//cout << endl;
	}

	int a = 0, b = 0;

	
	int max = -INT_MAX;
	for (int i = 1; i <= n-c+1; i++) {
		for (int j = 1; j <= m-c+1; j++) {
			int t = sum[i + c - 1][j + c - 1] + sum[i-1][j-1] - sum[i-1][j + c - 1] - sum[i + c - 1][j-1];
			if (t > max)
			{
				max = t;
				a = i;
				b = j;
			}
			//cout << t  << '(' << i << ',' << j << ')' << ' ';
		}
		//cout << endl;
	}
	cout << a << ' ' << b;
}
```
 
差分：

性质
* $a_i$的值是 $b_i$的前缀和，即 
* $a_n=\sum\limits_{i=1}^nb_i$
计算 a_i 的前缀和 
$sum=\sum\limits_{i=1}^na_i=\sum\limits_{i=1}^n\sum\limits_{j=1}^{i}b_j=\sum\limits_{i=1}^n(n-i+1)b_i$

例题：[P3397 地毯](https://www.luogu.com.cn/problem/P3397)
提示：

```
0 0 0 0 0
0 1 1 1 0
0 1 1 1 0
0 1 1 1 0
0 0 0 0 0
```
求差分后
```
0 0 0 0 0
0 1 0 0 -1
0 0 0 0 0
0 0 0 0 0
0 -1 0 0 1
```
代码
```c++
#include<iostream>
#include<vector>
#include<limits.h>

using namespace std;

int pre[1010][1010] = {};
int sum[1010][1010] = {};

int main() {

	int n, m;
	cin >> n >> m;
	while (m--){
		int x1, y1, x2, y2;
		cin >> x1 >> y1 >> x2 >> y2;
		pre[x1][y1] += 1;
		pre[x2 + 1][y2 + 1] += 1;
		pre[x2 + 1][y1] += -1;
		pre[x1][y2 + 1] += -1;

	}
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= n; j++) {
			sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + pre[i][j];
			cout << sum[i][j] << ' ';
		}
		cout << endl;
	}
	
}
```

参见[前缀和 & 差分(OI wiki)](https://oi-wiki.org/basic/prefix-sum/)

