[P1314 [NOIP2011 提高组] 聪明的质监员](https://www.luogu.com.cn/problem/P1314)
难度
普及+/提高

弄$|s-y|$就应该枚举所有$W$然后求最小值，不好三分
想要二分的话可以根据$w↑ y↓$

而且我还把$w_{max}$和$w_{min}$看成关于$v$了，又debug了好久

但是$w_{max}$相差$w_{min}$太大的话，直接一个一个枚举效率太低，可以弄set记录出现过的$w$

数据$0<s\leq10^{12}$,函数返回也要用long long返回
改了之后没有WA但是结果又是TLE了

TLE
```c++
#include<iostream>
#include<vector>
#include<set>
#include<limits.h>
#include<cctype>
#include<algorithm>
#include<map>
#include<functional>
#include<cmath>

using namespace std;

long long solve_y(vector<pair<int, int>>& v_ore, vector<pair<int, int>>& v_raange, int w,long long s) {
	long long total = 0;
	for (auto& x : v_raange) {
		long long p1 = 0;
		long long p2 = 0;
		for (int i = x.first - 1; i < x.second; i++) {
			if (v_ore[i].first >= w) {
				p1 += 1;
				p2 += v_ore[i].second;
			}
		}
		total += p1 * p2;
	}
	return abs(total - s);
}

int main() {

	int n, m;
	long long s;
	cin >> n >> m >> s;

	set<int> s_w;
	vector<pair<int, int>> v_ore(n);
	for (auto& x : v_ore) {
		cin >> x.first >> x.second;
		s_w.insert(x.first);
	}
	vector<pair<int, int>> v_range(m);
	for (auto& x : v_range)
		cin >> x.first >> x.second;

	vector<long long> y;
	for (auto& w : s_w)
		y.push_back(solve_y(v_ore, v_range, w, s));
	long long s_y_min = LLONG_MAX;
	for (auto& x : y)
		if (x < s_y_min)
			s_y_min = x;

	cout << s_y_min;
}
```

